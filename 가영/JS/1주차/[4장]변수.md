# 4장. 변수

## 변수란 무엇인가?

> 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말함.

- 변수는 프로그래밍 언어에서 값을 저장하고 참고하는 메커니즘으로 **값의 위치를 가리키는 상징적인 이름**임.
- 프로그래밍 언어의 컴파일러 또는 인터프리터에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행됨. → 개발자가 직접 메모리 주소를 통해 값을 저장하고 참조할 필요가 없고 **변수를 통해 안전하게 값에 접근**할 수 있음.
- 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름을 **변수 이름(또는 변수명)**이라 함. 변수에 저장된 값을 **변수 값**이라고 함.
- 변수에 값을 저장하는 것을 **할당(대입, 저장)** 이라 하고 변수에 저장된 값을 읽어 들이는 것을 **참조**라 함.

## 식별자(Identifier)

> 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말함. 사람을 이름으로 구별해서 식별하는 것처럼 값도 식별자로 구별해서 식별할 수 있음.

- 값은 메모리 공간에 저장되어 있어 식별자는 메모리 공간에 저장되어 있는 어떤 값을 구별해서 식별해낼 수 있어야 함.
  - 이를 위해 식별자는 어떤 값이 저장되어 있는 메모리 주소를 기억(저장)해야 함.
- 식별자는 값이 아니라 메모리 주소를 기억하고 있음.
  - 식별자로 값을 구별해서 식별한다는 것은 식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값을 접근할 수 있다는 의미임.
- 변수, 함수, 클래스 등의 이름과 같은 식별자는 **네이밍 규칙**을 준수해야 하며 **선언**에 의해 자바스크립트 엔진에 식별자의 존재를 알림.

## 변수 선언

> 변수를 생성하는 것을 말함.

- 값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것임.
- 변수 선언에 의해 확보된 메모리 공간은 확보가 해제되기 전까지는 누구도 확보된 메모리 공간을 사용할 수 없도록 보호되므로 안전하게 사용할 수 있음.
- **변수를 사용하려면 반드시 선언이 필요함**.
  - 변수를 선언할 때는 `var`, `let`, `const` 키워드를 사용함.
  - ES6에서 `let`, `const` 키워드가 도입되기 이전까지 `var` 키워드는 자바스크립트에서 변수를 선언할 수 있는 유일한 키워드였음.

### `var` 키워드 변수 선언 방법

> ES6에서 `let`과 `const` 키워드를 도입한 이유는 `var` 키워드의 여러 단점을 보완하기 위해서임.

```js
var score; // 변수 선언(변수 선언문)
```

- `var` 키워드 뒤에 오는 변수 이름을 등록하고 값을 저장할 메모리 공간을 확보함.
- 확보된 메모리 공간에는 자바스크립트 엔진에 의해 `undefined`라는 값이 암묵적으로 할당되어 초기화됨. → 자바스크립트의 독특한 특징임.
- 자바스크립트 엔진은 변수 선언을 다음과 같은 2단계에 거쳐 수행함.
  - **선언 단계**: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알림.
  - **초기화 단계**: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 `undefined`를 할당해 초기화함.
- `var` 키워드를 사용한 변수 선언은 **선언 단계와 초기화 단계가 동시에 진행**됨.
- 일반적으로 **초기화**란 변수가 선언된 이후 최초로 값을 할당하는 것을 말함.
- 만약 초기화 단계를 거치지 않으면 확보된 메모리 공간에는 이전에 다른 애플리케이션이 사용했던 값이 남아 있을 수 있음. → 이러한 값을 **쓰레기 값(garbage value)**이라 함.
- 메모리 공간을 확보한 다음 값을 할당하지 않은 상태에서 곧바로 변수 값을 참고하면 쓰레기 값이 나올 수 있는데 자바스크립트의 `var` 키워드는 암묵적으로 초기화를 수행하기 때문에 이러한 위험으로부터 안전함.

## 변수 선언의 실행 시점과 변수 호이스팅

#### 예제:

```js
console.log(score); // undefined

var score; // 변수 선언문
```

> 변수 선언문보다 변수를 참조하는 코드가 앞에 있음.

- 자바스크립트 코드는 **인터프리터**에 의해 한 줄씩 순차적으로 실행되므로 `console.log(score);` 가 가장 먼저 실행되고 다음 줄에 있는 코드를 실행함.
- `console.log(score);`가 실행되는 시점에 아직 `score` 변수의 선언이 실행되지 않았으므로 참조 에러가 발생할 것처럼 보임.
- 하지만 참조 에러가 발생하지 않고 `undefined`가 출력됨.
  - **변수 선언이 소스 코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임(runtime)이 아니라 그 이전 단계에서 먼저 실행되기 때문임**.
- 자바스크립트 엔진은 변수 선언이 소스 코드의 어디에 있든 상관없이 다른 코드보다 먼저 실행함.
  - 변수 선언이 소스 코드의 어디에 위치하는지와 상관없이 **어디서든 변수를 참조**할 수 있음.
- 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 **변수 호이스팅**이라고 함.

## 값의 할당

#### 예제:

```js
var score; // 변수 선언
score = 80; // 값의 할당
```

- 변수에 값을 할당(대입, 저장)할 때는 할당 연산자 `=`을 사용함. 할당 연산자는 우변의 값을 좌변의 변수에 할당함.

#### 예제:

```js
var score = 80; // 변수 선언과 값의 할당
```

- 변수 선언과 값의 할당을 하나의 문(statement)으로 단축 표현할 수도 있음.
- 자바스크립트 엔진은 변수 선언과 값의 할당을 하나의 문으로 단축 표현해도 2개의 문으로 나누어 각각 실행함.
- 이때 주의할 점은 변수 선언과 값의 할당의 **실행 시점이 다르다는 것**임.
  - 변수 선언은 소스 코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 값의 할당은 소스 코드가 순차적으로 실행되는 시점인 런타임에 실행됨.

#### 예제:

```js
console.log(score); // undefined

var score; // 변수 선언
score = 80; // 값의 할당

console.log(score); // 80
```

- 변수 선언은 런타임 이전에 실행되고 값의 할당은 런타임에 실행됨.
- `score` 변수에 값을 할당하는 시점에는 이미 변수 선언이 완료된 상태이며 이미 `undefined`로 초기화되어 있음.
- `score` 변수에 값을 할당하면 변수의 값은 `undefined`에서 새롭게 할당한 숫자 값 `80`으로 변경(재할당)됨.

## 값의 재할당

> 재할당이란 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것을 말함.

#### 예제:

```js
var score = 80; // 변수 선언과 값의 할당
score = 90; // 값의 재할당
```

- `var` 키워드로 선언한 변수는 값을 재할당할 수 있음.
- `var` 키워드로 선언한 변수는 선언과 동시에 `undefined`로 초기화되기 때문에 엄밀히 말하자면 변수에 처음으로 값을 할당하는 것도 사실은 **재할당**임.
- 재할당은 변수에 저장된 값을 다른 값으로 변경함. 그래서 변수라고 하는 것임.
- 만약 **값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다**면 변수가 아니라 **상수(constant)** 라고 함.
- 상수는 한 번 정해지면 변하지 않는 값이며 단 한 번만 할당할 수 있는 변수임.

## 식별자 네이밍 규칙

> 식별자는 다음과 같은 네이밍 규칙을 준수해야 함.
>
> - 특수문자를 제외한 문자, 숫자, 언더스코어(\_), 달러 기호($)를 포함할 수 있음.
> - 단, 숫자로 시작하는 것은 허용하지 않음.
> - 예약어는 식별자로 사용할 수 없음.

### 예약어(Reserved Word)

> 예약어는 프로그래밍 언어에서 이미 사용되고 있거나 사용될 예정인 단어를 말함.

| await       | break    | case         | catch   | class     | const      |
| :---------- | :------- | :----------- | :------ | :-------- | :--------- |
| continue    | debugger | default      | delete  | do        | else       |
| enum        | export   | extends      | false   | finally   | for        |
| function    | if       | implements\* | import  | in        | instanceof |
| interface\* | let\*    | new          | null    | package\* | private\*  |
| protected\* | public\* | return       | super   | static\*  | switch     |
| this        | throw    | true         | try     | typeof    | var        |
| void        | while    | with         | yield\* |           |            |

#### 예제:

```js
var person, $elem, _name, first_name, val1;
```

- **변수 이름도 식별자**이므로 위 네이밍 규칙을 따라야 함.
- 변수는 쉼표(,)로 구분해 하나의 문에서 여러 개를 한 번에 선언할 수 있지만 가독성이 나빠지므로 권장하지는 않음.

#### 예제:

```js
var 이름, なまえ;
```

- ES5부터 식별자를 만들 때 **유니코드 문자**를 허용하므로 알파벳 외의 한글이나 일본어 식별자도 사용할 수 있음.
- 하지만 알파벳 외의 유니코드 문자로 명명된 식별자를 사용하는 것은 바람직하지 않으므로 권장하지 않음.

#### 예제:

```js
var first-name; // SyntaxError: Unexpected token -
var 1st; // SyntaxError: Invalid or unexpected token
var this; // SyntaxError: Unexpected token this
```

- 다음 식별자는 명명 규칙에 위배되므로 변수 이름으로 사용할 수 없음.

#### 예제:

```js
var firstname;
var firstName;
var FIRSTNAME;
```

- 자바스크립트는 **대소문자를 구별**하므로 위 변수들은 모두 서로 다른 변수임.

#### 예제:

```js
var x = 3;
var score = 100;
```

- 변수 이름은 변수의 존재 목적을 쉽게 이해할 수 있도록 의미를 명확히 표현해야 함.
- 좋은 변수 이름은 코드의 가독성을 높임.

#### 예제:

```js
// 카멜 케이스(camelCase)
var firstName;

// 스네이크 케이스(snake_case)
var first_name;

// 파스칼 케이스(PascalCase)
var FirstName;

// 헝가리언 케이스(typeHungarianCase)
var strFirstName; // type + identifier
var $elem = document.getElementById("myId"); // DOM 노드
var observable$ = fromEvent(document, "click"); // RxJS 옵저버블
```

- **네이밍 컨벤션(naming convention)** 은 하나 이상의 영어 단어로 구성된 식별자를 만들 때 가독성 좋게 단어를 한눈에 구분하기 위해 규정한 명명 규칙임.
- 네이밍 컨벤션을 잘 지키면 읽기 좋은 이름을 만들 수 있음.
- 일관성을 유지한다면 어떤 네이밍 컨벤션을 사용해도 좋지만 자바스크립트에서는 일반적으로 변수나 함수의 이름에는 카멜 케이스를 사용하고 생성자 함수나 클래스의 이름에는 파스칼 케이스를 사용함.
- ECMAScript 사양에 정의되어 있는 객체와 함수들도 카멜 케이스와 파스칼 케이스를 사용하고 있음.
- 코드 전체의 가독성을 높이려면 **카멜 케이스**와 **파스칼 케이스**를 따르는 것이 유리함.
