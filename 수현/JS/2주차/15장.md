# let, const 키워드와 블록 레벨 스코프
## var 키워드로 선언한 변수의 문제점
### 변수 중복 선언 허용
```javascript
var x = 1;
var x = 100;

console.log(x); // 100
```
먼저 선언된 변수 값이 변경될 수 있음.

### 함수 레벨 스코프
```javascript
var i = 1;

if (true) {
    var x = 10; // x는 전역 변수이므로 해당 변수도 전역변수임.
}

console.log(x); //10, 함수 내에서 값이 변경되었지만 전역변수가 값을 그대로 가져옴.
```

## 변수 호이스팅
선언 이전에 변수를 사용하면 undefined를 반환.

## let 키워드
### 변수 중복 선언 금지
```javascript
let bar = 123;
let bar = 345; //error
```

### 블록 레벨 스코프
- let키워드로 선언한 변수는 모든 코드 블록을 지역 스코프로 인정하는 블록 레벨 스코프를 따름.
```javascript
let foo = 1;
{
    let foo = 2;
}
console.log(foo); //1
```

### 변수 호이스팅
- let변수는 [ 선언단계 > 일시적 사각지대 > 초기화 단계 > 할당단계 ]를 거침.
- 초기화 단계가 이루어지기 전엔 error가 발생.

## const 키워드
### 선언과 초기화
- const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화 해야 함.
### 재할당 금지
- const 키워드로 선언한 변수는 재할당이 금지됨.
### 상수
- const 키워드로 선언된 변수에 원시 값을 할당한 경우 원시 값은 변경할 수 없는 값이고, const 키워드에 의해 재할당이 금지되므로 할당된 값을 변경할 수 있는 방법은 없음.
### const 키워드와 객체
- xonst 키워드로 선언된 변수에 객체를 할당한 경우 값을 변경할 수 있음.
```javascript
const person = {
    name = 'Lee';
}

person.name = 'Kim';
// 객체는 변경 가능한 값. 따라서 재할당 없이 변경이 가능
console.log(person);
```
const 키워드는 재할당을 금지할 뿐 **불변**을 의미하진 않음.

## var vs. let vs. const
- ES6를 사용한다면 var 키워드는 사용하지 않는다.
- 재할당이 필요한 경우에 한정해 let 키워드를 사용한다. 이때 변수의 스코프는 최대한 좁게 만든다.
- 변경이 발생하지 않고 읽기 전용으로 사용하는 (재할당이 필요 없는 상수) 원시 값과 객체에는 const 키워드를 사용한다. const 키워드는 재할당을 금지하므로 var, let 보다 안전하다.

